#include <iostream>
#include <gcc-plugin.h>
#include <plugin-version.h>

#include "tree-pass.h"
#include "context.h"
#include "function.h"
#include "tree.h"
#include "tree-ssa-alias.h"
#include "internal-fn.h"
#include "is-a.h"
#include "predict.h"
#include "basic-block.h"
#include "gimple-expr.h"
#include "gimple.h"
#include "gimple-pretty-print.h"
#include "gimple-iterator.h"
#include "gimple-walk.h"
#include "hash-map.h"
#include "hash-set.h"
#include "cgraph.h"
int plugin_is_GPL_compatible;

// TODO warning &dlsym &func->dlsym
// TODO overriden functions (same names, different sym_pos)
struct signature
{
  const char* func_name;
  size_t sym_pos;
};

/* TODO add considered_functions and change the parse_call signature
   according to the call info */
struct call_info
{
  /* Function, where dynamic call appears  */
  function* func;
  /* Signature of dynamic call */
  struct signature sign;
};

static vec<struct signature> signatures;
static hash_set<const char*> considered_functions;
static hash_map<const char*, hash_set<const char*, nofree_string_hash>*> dynamic_symbols;

static bool parse_symbol (struct cgraph_node *node, tree symbol, struct signature *sign)
{
  // Constant string
  if (TREE_CODE (symbol) == ADDR_EXPR &&
      TREE_CODE (TREE_OPERAND (symbol, 0)) == STRING_CST)
    {
      const char *symname = TREE_STRING_POINTER (TREE_OPERAND (symbol, 0));
      auto symbols = dynamic_symbols.get (sign->func_name);

      if (!symbols)
	{
	  auto empty_symbols = new hash_set<const char*, nofree_string_hash>;
	  dynamic_symbols.put (sign->func_name, empty_symbols);
	  symbols = &empty_symbols;
	}
      (*symbols)->add (symname);
      return true;
    }		   

  if (TREE_CODE (symbol) == SSA_NAME)
    {
      bool result = true;
      unsigned HOST_WIDE_INT i;
      gimple* def_stmt;
      // Parse function argument, make recursive step
      if (SSA_NAME_IS_DEFAULT_DEF (symbol))
	{
	  unsigned HOST_WIDE_INT arg_num;
	  tree t;
	  tree sym_decl = SSA_NAME_IDENTIFIER (symbol);
	  struct cgraph_edge *cs;
	  const char *caller_name, *subsymname = IDENTIFIER_POINTER (sym_decl);

	  for (arg_num = 0, t = DECL_ARGUMENTS (node->get_fun ()->decl);
	       t;
	       t = DECL_CHAIN (t), arg_num++)
	    if (DECL_NAME (t) == sym_decl)
	      break;
	  /* If no callers or SYMBOL is not represented in DECL_ARGUMENTS
	     we cannot resolve the possible set of symbols */
	  if (!node->callers || !t)
	    return false;
	  for (cs = node->callers; cs; cs = cs->next_caller)
	    {
	      struct signature subsign = { .func_name = sign->func_name, 
		  .sym_pos = arg_num };
	      caller_name = IDENTIFIER_POINTER (DECL_NAME (cs->caller->get_fun ()->decl));
	      if (considered_functions.contains (caller_name))
		  return true;

	      considered_functions.add (caller_name);
	      // TODO indirect calls
	      if (stderr)
		{
		  fprintf (stderr, "\tTrack %s symbol obtained from:\n\t\t",
			   subsymname);
		  print_gimple_stmt (stderr, cs->call_stmt, 0, 0);
		}
	      tree symbol1 = gimple_call_arg (cs->call_stmt, arg_num);
	      result &= parse_symbol (cs->caller, symbol1, &subsign);
	      considered_functions.remove (caller_name);
	    }
	  return result;
	}
      // Go to definition and try to determine the set of possible values
      def_stmt = SSA_NAME_DEF_STMT (symbol);
      switch (gimple_code (def_stmt))
	{
	case GIMPLE_ASSIGN:
	  return false;
	case GIMPLE_PHI:
	  /*TODO phi cycles, currently anavalable because of absence of 
	    string changing track */
	  if (stderr)
	    fprintf (stderr, "\tPHI statement def: iterate each of them\n");
	  for (i = 0; i < gimple_phi_num_args (def_stmt); i++)
	    {
	      tree arg = gimple_phi_arg_def (def_stmt, i);
	      result &= parse_symbol (node, arg, sign);
	    }
	  return result;
	default:
	  return false;
	}
      // TODO handle simple expressions (global_const.c)
      return false;
    }
  return false;
}
void print_body (struct function* fun)
{
  basic_block bb;
  fprintf (stderr, "Body:\n");
  if (!fun)
    return;
  FOR_EACH_BB_FN (bb, fun)
    {
      gimple_stmt_iterator i;
      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))
	print_gimple_stmt (stderr, gsi_stmt (i), 0, TDF_SLIM);
    }
}
void process_calls (struct cgraph_node *node)
{
  size_t i;
  struct cgraph_edge *cs;
  if (stderr)
    fprintf (stderr, "Calls:\n");
  for (cs = node->callees; cs; cs = cs->next_callee)
    {
      for (i = 0; i < signatures.length (); ++i)
	{
	  if (!strcmp (signatures[i].func_name, cs->callee->name ()))
	    {
	      if (stderr)
		fprintf (stderr, "\t%s matched to the signature\n", cs->callee->name ());
	      tree symbol = gimple_call_arg (cs->call_stmt, signatures[i].sym_pos);
	      if (!parse_symbol (node, symbol, &signatures[i]) && stderr) 
		{
		  fprintf (stderr, "\t%s set is not limited\n", cs->callee->name ());
		}
	    }
	}
    }
}


namespace
{
  const pass_data dlsym_pass_data = 
    {
      IPA_PASS,
      "dlsym",			/* name */
      OPTGROUP_NONE,		/* optinfo_flags */
      TV_NONE,			/* tv_id */
      ( PROP_cfg | PROP_ssa ),  /* properties_required */
      0,			/* properties_provided */
      0,			/* properties_destroyed */
      0, //TODO_rebuild_cgraph_edges,/* todo_flags_start */
      0				/* todo_flags_finish */
    };

  class dlsym_pass : public ipa_opt_pass_d
  {
public:
    dlsym_pass(gcc::context *ctx)
      : ipa_opt_pass_d(dlsym_pass_data, ctx,
		       NULL,
		       NULL,
		       NULL,
		       NULL,
		       NULL,
		       NULL,
		       0, 
		       NULL,
		       NULL)
      {
	struct signature initial = { .func_name = "dlsym",  .sym_pos = 1 };
	signatures.safe_push (initial);
      }

    virtual unsigned int execute(function *) override
      {
	struct cgraph_node* node;// = cgraph_node::get(fun->decl);

	//fprintf(stderr, "FUNCTION \'%s\' at %s:%d\n", 
	//	function_name(fun),
	//	LOCATION_FILE(fun->function_start_locus),
	//	LOCATION_LINE(fun->function_start_locus));
	//	fprintf(stderr, "*******************\n");
	FOR_EACH_DEFINED_FUNCTION (node)
	  {
	    //  if (!node->has_gimple_body_p () || node->global.inlined_to)
	    //    continue;
	    //	    node->get_body ();

	    if (stderr)
	      {
		fprintf (stderr, "Call graph node:\n");
		node->dump (stderr);
		fprintf (stderr, "\n\n");
	      }
	    print_body (node->get_fun ());
	    process_calls (node);
	    if (stderr)
	      {
		fprintf (stderr, "Call\\Symbols:\n");
		for (auto it = dynamic_symbols.begin (); 
		     it != dynamic_symbols.end ();
		     ++it)
		  {
		    fprintf(stderr, "%s->%s->[", function_name(node->get_fun()),
			    (*it).first);
		    for (auto it2 = (*it).second->begin (); 
			 it2 != (*it).second->end ();
			 ++it2)
		      {
			if (it2 != (*it).second->begin ())
			  fprintf (stderr, ",");
			fprintf (stderr, "%s", *it2); 
		      }
		    fprintf(stderr, "]\n");
		  }
		fprintf(stderr, "\n\n");
	      }
	    for (auto it = dynamic_symbols.begin (); 
		 it != dynamic_symbols.end ();
		 ++it)
		delete (*it).second;
	    dynamic_symbols.empty ();
	  }
	return 0;
      }

    virtual bool gate (function *) { return true; }
    virtual dlsym_pass* clone() override
      {
	// We do not clone ourselves
	return this;
      }
  };
}

int
plugin_init (plugin_name_args *plugin_info, 
	     plugin_gcc_version *version)
{
  if (!plugin_default_version_check (&gcc_version ,version))
      return 1; 

  struct register_pass_info pass_info;
  pass_info.pass = new dlsym_pass(g);
  pass_info.reference_pass_name = "comdats";
  pass_info.ref_pass_instance_number = 1;
  pass_info.pos_op = PASS_POS_INSERT_AFTER;

  register_callback (plugin_info->base_name,
		     PLUGIN_PASS_MANAGER_SETUP, NULL,
		     &pass_info);
  return 0;
}
