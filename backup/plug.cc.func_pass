#include <iostream>
#include <gcc-plugin.h>
#include <plugin-version.h>

#include "tree-pass.h"
#include "context.h"
#include "function.h"
#include "tree.h"
#include "tree-ssa-alias.h"
#include "internal-fn.h"
#include "is-a.h"
#include "predict.h"
#include "basic-block.h"
#include "gimple-expr.h"
#include "gimple.h"
#include "gimple-pretty-print.h"
#include "gimple-iterator.h"
#include "gimple-walk.h"
#include "hash-map.h"
#include "hash-set.h"
#include "cgraph.h"
int plugin_is_GPL_compatible;

// TODO warning &dlsym &func->dlsym
// TODO overriden functions (same names, different sym_pos)
struct signature
{
  const char* func_name;
  size_t sym_pos;
};

/* TODO add considered_functions and change the parse_call signature
   according to the call info */
struct call_info
{
  /* Function, where dynamic call appears  */
  function* func;
  /* Signature of dynamic call */
  struct signature sign;
};

static vec<struct signature> signatures;
static hash_set<const char*> considered_functions;
static hash_map<const char*, hash_set<const char*, nofree_string_hash>*> dynamic_symbols;

static bool parse_symbol (struct cgraph_node *node, tree symbol, struct signature *sign)
{
  // Constant string
  if (TREE_CODE (symbol) == ADDR_EXPR &&
      TREE_CODE (TREE_OPERAND (symbol, 0)) == STRING_CST)
    {
      const char *symname = TREE_STRING_POINTER (TREE_OPERAND (symbol, 0));
      auto symbols = dynamic_symbols.get (sign->func_name);

      if (!symbols)
	{
	  auto empty_symbols = new hash_set<const char*, nofree_string_hash>;
	  dynamic_symbols.put (sign->func_name, empty_symbols);
	  symbols = &empty_symbols;
	}
      (*symbols)->add (symname);
      return true;
    }		   

  if (TREE_CODE (symbol) == SSA_NAME)
    {
      bool result = true;
      unsigned HOST_WIDE_INT i;
      gimple* def_stmt;
      // Parse function argument, make recursive step
      if (SSA_NAME_IS_DEFAULT_DEF (symbol))
	{
	  unsigned HOST_WIDE_INT arg_num;
	  tree t;
	  tree sym_decl = SSA_NAME_IDENTIFIER (symbol);
	  struct cgraph_edge *cs;
	  const char *caller_name, *subsymname = IDENTIFIER_POINTER (sym_decl);

	  for (arg_num = 0, t = DECL_ARGUMENTS (node->get_fun ()->decl);
	       t;
	       t = DECL_CHAIN (t), arg_num++)
	    if (DECL_NAME (t) == sym_decl)
	      break;
	  /* If no callers or SYMBOL is not represented in DECL_ARGUMENTS
	     we cannot resolve the possible set of symbols */
	  if (!node->callers || !t)
	    return false;
	  for (cs = node->callers; cs; cs = cs->next_caller)
	    {
	      struct signature subsign = { .func_name = sign->func_name, 
		  .sym_pos = arg_num };
	      caller_name = IDENTIFIER_POINTER (DECL_NAME (cs->caller->get_fun ()->decl));
	      if (considered_functions.contains (caller_name))
		  return true;

	      considered_functions.add (caller_name);
	      // TODO indirect calls
	      if (dump_file)
		{
		  fprintf (dump_file, "\tTrack %s symbol obtained from:\n\t\t",
			   subsymname);
		  print_gimple_stmt (dump_file, cs->call_stmt, 0, 0);
		}
	      tree symbol1 = gimple_call_arg (cs->call_stmt, arg_num);
	      result &= parse_symbol (cs->caller, symbol1, &subsign);
	      considered_functions.remove (caller_name);
	    }
	  return result;
	}
      // Go to definition and try to determine the set of possible values
      def_stmt = SSA_NAME_DEF_STMT (symbol);
      switch (gimple_code (def_stmt))
	{
	case GIMPLE_ASSIGN:
	  return false;
	case GIMPLE_PHI:
	  /*TODO phi cycles, currently anavalable because of absence of 
	    string changing track */
	  if (dump_file)
	    fprintf (dump_file, "\tPHI statement def: iterate each of them\n");
	  for (i = 0; i < gimple_phi_num_args (def_stmt); i++)
	    {
	      tree arg = gimple_phi_arg_def (def_stmt, i);
	      result &= parse_symbol (node, arg, sign);
	    }
	  return result;
	default:
	  return false;
	}
      // TODO handle simple expressions (global_const.c)
      return false;
    }
  return false;
}

void process_calls (struct cgraph_node *node)
{
  size_t i;
  struct cgraph_edge *cs;
  if (dump_file)
    fprintf (dump_file, "Calls:\n");
  for (cs = node->callees; cs; cs = cs->next_callee)
    {
      for (i = 0; i < signatures.length (); ++i)
	{
	  if (!strcmp (signatures[i].func_name, cs->callee->asm_name ()))
	    {
	      if (dump_file)
		fprintf (dump_file, "\t%s matched to the signature\n", cs->callee->name ());
	      tree symbol = gimple_call_arg (cs->call_stmt, signatures[i].sym_pos);
	      if (!parse_symbol (node, symbol, &signatures[i]) && dump_file) 
		{
		  fprintf (dump_file, "\t%s set is not limited\n", cs->callee->name ());
		}
	    }
	}
    }
}


namespace
{
  const pass_data dlsym_pass_data = 
    {
      GIMPLE_PASS,
      "dlsym",			/* name */
      OPTGROUP_NONE,		/* optinfo_flags */
      TV_NONE,			/* tv_id */
      ( PROP_cfg | PROP_ssa ),  /* properties_required */
      0,			/* properties_provided */
      0,			/* properties_destroyed */
      TODO_rebuild_cgraph_edges,/* todo_flags_start */
      0				/* todo_flags_finish */
    };

  struct dlsym_pass : gimple_opt_pass
  {
    dlsym_pass(gcc::context *ctx)
      : gimple_opt_pass(dlsym_pass_data, ctx)
      {
	struct signature initial = { .func_name = "dlsym",  .sym_pos = 1 };
	signatures.safe_push (initial);
      }

    virtual unsigned int execute(function *fun) override
      {
	struct cgraph_node* node = cgraph_node::get(fun->decl);

	//fprintf(stderr, "FUNCTION \'%s\' at %s:%d\n", 
	//	function_name(fun),
	//	LOCATION_FILE(fun->function_start_locus),
	//	LOCATION_LINE(fun->function_start_locus));
	//	fprintf(stderr, "*******************\n");
	if (dump_file)
	  {
	    fprintf (dump_file, "Call graph node:\n");
	    node->dump (dump_file);
	    fprintf (dump_file, "\n\n");
	  }
	process_calls (node);
	if (dump_file)
	  {
	    fprintf (dump_file, "Call\\Symbols:\n");
	    for (auto it = dynamic_symbols.begin (); 
		 it != dynamic_symbols.end ();
		 ++it)
	      {
		  fprintf(dump_file, "%s->%s->[", function_name(fun),
			  (*it).first);
		for (auto it2 = (*it).second->begin (); 
		     it2 != (*it).second->end ();
		     ++it2)
		  {
		    if (it2 != (*it).second->begin ())
		      fprintf (dump_file, ",");
		    fprintf (dump_file, "%s", *it2); 
		  }
		  delete (*it).second;
		  fprintf(dump_file, "]\n");
	      }
	    fprintf(dump_file, "\n\n");
	  }
	dynamic_symbols.empty ();
	return 0;
      }

    virtual dlsym_pass* clone() override
      {
	// We do not clone ourselves
	return this;
      }
  };
}

int
plugin_init (plugin_name_args *plugin_info, 
	     plugin_gcc_version *version)
{
  if (!plugin_default_version_check (&gcc_version ,version))
      return 1; 

  struct register_pass_info pass_info;
  pass_info.pass = new dlsym_pass(g);
  pass_info.reference_pass_name = "loop";
  pass_info.ref_pass_instance_number = 1;
  pass_info.pos_op = PASS_POS_INSERT_BEFORE;

  register_callback (plugin_info->base_name,
		     PLUGIN_PASS_MANAGER_SETUP, NULL,
		     &pass_info);
  return 0;
}
