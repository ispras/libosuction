#include <iostream>
#include <gcc-plugin.h>
#include <plugin-version.h>

#include "tree-pass.h"
#include "context.h"
#include "function.h"
#include "tree.h"
#include "tree-ssa-alias.h"
#include "internal-fn.h"
#include "is-a.h"
#include "predict.h"
#include "basic-block.h"
#include "gimple-expr.h"
#include "gimple.h"
#include "gimple-pretty-print.h"
#include "gimple-iterator.h"
#include "gimple-walk.h"
#include "hash-map.h"
#include "hash-set.h"
#include "cgraph.h"
int plugin_is_GPL_compatible;

// TODO overriden functions (same names, different sym_pos)
struct signature
{
  const char* func_name;
  size_t sym_pos;
};

static vec<struct signature> signatures;
static hash_map<const char*, hash_set<const char*>*> dynamic_symbols;

static void parse_call (struct cgraph_node *node, gimple *call, struct signature *sign)
{
  tree symbol = gimple_call_arg (call, sign->sym_pos);

  // Constant string argument
  if (TREE_CODE (symbol) == ADDR_EXPR &&
      TREE_CODE (TREE_OPERAND (symbol, 0)) == STRING_CST)
    {
      const char *symname = TREE_STRING_POINTER (TREE_OPERAND (symbol, 0));
      hash_set<const char*> **symbols = dynamic_symbols.get (sign->func_name);

      if (symbols)
	(*symbols)->add (symname);
      else
	{
	  hash_set<const char*> *empty_symbols = new hash_set<const char*>;
	  empty_symbols->add (symname);
	  dynamic_symbols.put (sign->func_name, empty_symbols);
	}
      return;
    }		   

  // wrapper function
  if (SSA_NAME_IS_DEFAULT_DEF (symbol))
    {
      
    }
}

//static void process_function(function *fun)
//{
//  tree fn;
//  const char* fn_name;
//  gimple *stmt;
//  struct cgraph_node *node;
//  struct cgraph_edge *cs;
//  basic_block bb;
//
//  node = cgraph_node::get(fun->decl);
//  
//  for (cs = node->callees; cs; cs = cs->next_callee)
//      fprintf (stderr, "\t%s\n", cs->callee->name ());
//
//  FOR_EACH_DEFINED_FUNCTION (node)
//  {
//  for (cs = node->callees; cs; cs = cs->next_callee)
//      fprintf (stderr, "\t%s\n", cs->callee->name ());
//  }
//  FOR_EACH_BB_FN (bb, fun)
//    {
//      gimple_stmt_iterator i;
//      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))
//	{
//	  stmt = gsi_stmt (i);
//	  switch (gimple_code (stmt))
//	    {    
//	    case GIMPLE_CALL:
//	      fprintf(stderr, "Initial Statement: ");
//	      print_gimple_stmt (stderr, stmt, 0, TDF_SLIM);
//	      fn = gimple_call_fn (stmt);
//	      if (TREE_CODE (fn) != ADDR_EXPR)
//		break;
//	      fn_name = IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND(fn, 0)));
//	      if (!strcmp (fn_name, "dlopen"))
//		record_library (stmt);
//	      else if (!strcmp (fn_name, "dlsym"))
//		record_symbol (stmt);
//	      break;
//	    default:
//	      break;
//	    }
//	}
//    }
//}
	//	process_function (fun);
	//	fprintf(stderr, "Libraries:\n");
	//
	//	for (hash_map<const char*, hash_set<const char*>*>::iterator it = libname_symbol->begin (); 
	//	     it != libname_symbol->end ();
	//	     ++it)
	//	  {
	//	    fprintf(stderr, "%s\n", (*it).first);	
	//	    for (hash_set<const char*>::iterator it2 = (*it).second->begin (); 
	//		 it2 != (*it).second->end ();
	//		 ++it2)
	//	      fprintf(stderr, "\t%s\n", (*it2));
	//	  }
void print_body (struct function* fun)
{
  basic_block bb;
  fprintf (stderr, "Body:\n");
  if (!fun)
    return;
  FOR_EACH_BB_FN (bb, fun)
    {
      gimple_stmt_iterator i;
      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))
	print_gimple_stmt (stderr, gsi_stmt (i), 0, TDF_SLIM);
    }
}

void process_calls (struct cgraph_node *node)
{
  size_t i;
  struct cgraph_edge *cs;
  fprintf (stderr, "Calls:\n");
  for (cs = node->callees; cs; cs = cs->next_callee)
    {
      for (i = 0; i < signatures.length (); ++i)
	{
	  if (!strcmp (signatures[i].func_name, cs->callee->name ()))
	    {
	      parse_call (cs->callee, cs->call_stmt, &signatures[i]);
	      fprintf (stderr, "\t%s matched to the signature\n", cs->callee->name ());
	    }
	}
    }
}

void after_ipa_callback (void *, void *)
{
  struct cgraph_node *node;
  struct function *fun;

  struct signature initial = { .func_name = "dlsym",  .sym_pos = 1 };
  signatures.safe_push (initial);

  fprintf (stderr, "*******************\n");
//  FOR_EACH_DEFINED_FUNCTION (node)
//    {
//      if (gimple_has_body_p (node->decl) && !node->global.inlined_to)//node->has_gimple_body_p () && !node->global.inlined_to)
//	node->get_body ();
//    }
  FOR_EACH_DEFINED_FUNCTION (node)
    {
      fun = node->get_fun ();
      node->dump (stderr);
      fprintf (stderr, "FUNCTION \'%s\' at %s:%d\n", 
	       function_name (fun));
      print_body (fun);
      process_calls (node);
      fprintf (stderr, "-------------------\n");
    }
  fprintf (stderr, "Symbols:\n");
  for (hash_map<const char*, hash_set<const char*>*>::iterator it = dynamic_symbols.begin (); 
       it != dynamic_symbols.end ();
       ++it)
    {
      fprintf (stderr, "%s\n", (*it).first);	
      for (hash_set<const char*>::iterator it2 = (*it).second->begin (); 
	   it2 != (*it).second->end ();
	   ++it2)
	fprintf (stderr, "\t%s\n", (*it2));
    }

  fprintf (stderr, "*******************\n\n");
  //  cgraph_node::debug_cgraph ();
}

int
plugin_init (plugin_name_args *plugin_info, 
	     plugin_gcc_version *version)
{
  if (!plugin_default_version_check (&gcc_version ,version))
    return 1; 

  register_callback (plugin_info->base_name,
		     PLUGIN_ALL_IPA_PASSES_END,
		     //PLUGIN_ALL_PASSES_START,
		     //PLUGIN_EARLY_GIMPLE_PASSES_END,
		     &after_ipa_callback,
		     NULL);
  return 0;
}
