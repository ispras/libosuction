#include <iostream>
#include <gcc-plugin.h>
#include <plugin-version.h>

#include "tree-pass.h"
#include "context.h"
#include "function.h"
#include "tree.h"
#include "tree-ssa-alias.h"
#include "internal-fn.h"
#include "is-a.h"
#include "predict.h"
#include "basic-block.h"
#include "gimple-expr.h"
#include "gimple.h"
#include "gimple-pretty-print.h"
#include "gimple-iterator.h"
#include "gimple-walk.h"
#include "hash-map.h"
#include "hash-set.h"
int plugin_is_GPL_compatible;

static hash_map <tree, const char*> *ssa_libname;
static hash_map <const char*, hash_set<const char*>*> *libname_symbol;

// TODO global variables
static void record_library (gimple *stmt)
{
  fprintf (stderr, "Library: ");
  tree name = gimple_call_arg (stmt, 0);
  if (TREE_CODE (name) == ADDR_EXPR &&
      TREE_CODE (TREE_OPERAND (name, 0)) == STRING_CST)
    {
      const char *libname = TREE_STRING_POINTER (TREE_OPERAND (name, 0));
      fprintf (stderr, "%s\n", libname);
      ssa_libname->put (gimple_call_lhs (stmt) ,libname);
    }		   
  else 
    {
      fprintf (stderr, "undefined\n");
    }	    
}

static void record_symbol (gimple *stmt)
{
  // TODO symbols without library
  fprintf(stderr, "Dynamic call: ");
  tree handler = gimple_call_arg (stmt, 0);
  tree symbol = gimple_call_arg (stmt, 1);
  if (TREE_CODE (symbol) == ADDR_EXPR &&
      TREE_CODE (TREE_OPERAND (symbol, 0)) == STRING_CST)
    {
      const char *symname = TREE_STRING_POINTER (TREE_OPERAND (symbol, 0));
      fprintf (stderr, "%s\n", symname);
      const char **libname = ssa_libname->get (handler);
      hash_set<const char*> **symbols = libname_symbol->get (*libname);
      if (symbols)
	(*symbols)->add (symname);
      else
	{
	  hash_set<const char*> *empty_symbols = new hash_set<const char*>;
	  empty_symbols->add (symname);
	  libname_symbol->put (*libname, empty_symbols);
	}
    }		   
  else 
    {
      fprintf(stderr, "undefined\n");
    }	    

}

static void process_function(function *fun)
{
  tree fn;
  const char* fn_name;
  gimple *stmt;
  basic_block bb;

  FOR_EACH_BB_FN (bb, fun)
    {
      gimple_stmt_iterator i;
      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))
	{
	  stmt = gsi_stmt (i);
	  switch (gimple_code (stmt))
	    {    
	    case GIMPLE_CALL:
	      fprintf(stderr, "Initial Statement: ");
	      print_gimple_stmt (stderr, stmt, 0, TDF_SLIM);
	      fn = gimple_call_fn (stmt);
	      if (TREE_CODE (fn) != ADDR_EXPR)
		break;
	      fn_name = IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND(fn, 0)));
	      if (!strcmp (fn_name, "dlopen"))
		record_library (stmt);
	      else if (!strcmp (fn_name, "dlsym"))
		record_symbol (stmt);
	      break;
	    default:
	      break;
	    }
	}
    }
}

namespace
{
  const pass_data dlsym_pass_data = 
    {
      GIMPLE_PASS,
      "dlsym",        /* name */
      OPTGROUP_NONE,          /* optinfo_flags */
      TV_NONE,                /* tv_id */
      ( PROP_cfg | PROP_ssa ),        /* properties_required */
      0,		      /* properties_provided */
      0,		      /* properties_destroyed */
      0,		      /* todo_flags_start */
      0			      /* todo_flags_finish */
    };

  struct dlsym_pass : gimple_opt_pass
  {
    dlsym_pass(gcc::context *ctx)
      : gimple_opt_pass(dlsym_pass_data, ctx)
      {
      }

    virtual unsigned int execute(function *fun) override
      {
	ssa_libname = new hash_map<tree, const char *>;
	libname_symbol = new hash_map<const char*, hash_set<const char*>*>;
	fprintf(stderr, "FUNCTION \'%s\' at %s:%d\n", 
		function_name(fun),
		LOCATION_FILE(fun->function_start_locus),
		LOCATION_LINE(fun->function_start_locus));
	fprintf(stderr, "*******************\n");
	process_function (fun);
	fprintf(stderr, "Libraries:\n");

	for (hash_map<const char*, hash_set<const char*>*>::iterator it = libname_symbol->begin (); 
	     it != libname_symbol->end ();
	     ++it)
	  {
	    fprintf(stderr, "%s\n", (*it).first);	
	    for (hash_set<const char*>::iterator it2 = (*it).second->begin (); 
		 it2 != (*it).second->end ();
		 ++it2)
	      fprintf(stderr, "\t%s\n", (*it2));
	  }
	fprintf(stderr, "*******************\n\n");
	// TODO delete vectors in cells
	delete(libname_symbol);
	delete(ssa_libname);
	libname_symbol = NULL;
	ssa_libname = NULL;
	return 0;
      }

    virtual dlsym_pass* clone() override
      {
	// We do not clone ourselves
	return this;
      }
  };
}

int
plugin_init (plugin_name_args *plugin_info, 
	     plugin_gcc_version *version)
{
  if (!plugin_default_version_check (&gcc_version ,version))
      return 1; 

  struct register_pass_info pass_info;
  pass_info.pass = new dlsym_pass(g);
  pass_info.reference_pass_name = "loop";
  pass_info.ref_pass_instance_number = 1;
  pass_info.pos_op = PASS_POS_INSERT_BEFORE;

  register_callback (plugin_info->base_name,
		     PLUGIN_PASS_MANAGER_SETUP, NULL,
		     &pass_info);
  return 0;
}
